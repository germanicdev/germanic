# Security Fixes Protokoll

## Findings behoben:

- **F1** `dynamic/mod.rs:47-58, 86-88` + `main.rs:187-192` + `pre_validate.rs:41-58` — Size check BEFORE JSON parsing in `compile_dynamic()` and `cmd_compile()`. New `pre_validate_value()` for `compile_dynamic_from_values()`. Full `pre_validate()` call after parse in dynamic compile path.
- **F2** `main.rs:356-368, 414-417` — `cmd_validate()` returns `Err(...)` when `result.valid == false`. `cmd_inspect()` returns `Err(...)` on header parse failure. Both now exit with code 1 on invalid input.
- **F3** `mcp.rs:93-115` — New `check_file_size()` helper checks `fs::metadata()` against `MAX_INPUT_SIZE` before any `read_to_string()`. Applied to all 5 MCP handlers that read files: `germanic_compile` (schema + data), `germanic_validate`, `germanic_inspect`, `germanic_init`, `germanic_convert`.
- **F4** `types.rs:101-109, 233-239` — `GrmHeader::to_bytes()` returns `Result<Vec<u8>, HeaderParseError>` instead of panicking. New `HeaderParseError::SchemaIdTooLong` variant. All call sites updated (`compiler.rs`, `dynamic/mod.rs` x2, tests).
- **F5** `validator.rs:88-104` — After header parsing, payload is checked for: (1) empty payload, (2) minimum FlatBuffer size (8 bytes). Returns invalid with descriptive error message.
- **F6** `generated.rs` — Added safety comment documenting that all unsafe blocks are auto-generated by flatc.
- **F7-F10** — No code changes needed. Path traversal blocked (F7), schema injection impossible (F8), no network deps (F9), MCP behind feature flag (F10). All confirmed correct.
- **F11** `.github/workflows/ci.yml` — New `audit` job using `rustsec/audit-check@v2`.

## Abweichungen vom AP:

- **F1 Architektur**: Split the size check into two phases: raw `json_str.len()` check BEFORE `serde_json::from_str()` (avoids parsing 100MB+ files), then full `pre_validate()` AFTER parsing for value-tree checks. This is more efficient than calling `pre_validate()` after parsing the whole thing, because we reject oversized input before the serde overhead.
- **F1 Value-only path**: Created `pre_validate_value()` as a public function (not by making `check_value()` pub), which mirrors `pre_validate()` but without the raw-string size check. Cleaner API surface.
- **F3 Scope**: Applied `check_file_size()` to ALL 5 file-reading MCP handlers (compile schema+data, validate, inspect, init, convert), not just the 2 mentioned in the AP. Defense in depth.
- **F4 Error propagation**: Used `.map_err(|e| GermanicError::General(e.to_string()))` instead of adding a new `HeaderParse` variant to `GermanicError`. This avoids a public API change (new enum variant would break exhaustive matches in downstream code).
- **F5 Depth**: Implemented payload plausibility checks (empty + minimum 8 bytes for FlatBuffer). Did not attempt full `flatbuffers::root::<T>()` verification because the generic validator doesn't know the concrete FlatBuffer type at runtime — that would require a schema registry mapping schema_ids to types, which is out of scope for a patch release.

## Test-Ergebnisse:

- `cargo test --workspace`: 113 tests, 0 failures
- `cargo test --workspace --features mcp`: 121 tests, 0 failures
- New tests:
  - `test_header_rejects_oversized_schema_id` (types.rs)
  - `test_pre_validate_value_string_too_long` (pre_validate.rs)
  - `test_pre_validate_value_valid` (pre_validate.rs)
  - `test_validate_grm_empty_payload` (validator.rs)
  - `test_validate_grm_payload_too_short` (validator.rs)
- Manual retest:
  - F1: Oversized input (6.1MB) rejected with "input size ... exceeds maximum", exit 1
  - F2: Invalid .grm → exit 1, valid .grm → exit 0
  - F2: Inspect invalid .grm → exit 1
  - F5: Corrupt .grm detected and rejected, exit 1
- `cargo clippy --workspace --all-targets -- -D warnings`: clean
- `cargo clippy --workspace --all-targets --features mcp -- -D warnings`: clean
- `cargo fmt --all -- --check`: clean
- `cargo audit`: not installed locally (CI job added)

## Integration Tests (Nachtrag)

Neuer Testfile: `crates/germanic/tests/security_integration.rs`

Tests hinzugefuegt:
- `compile_dynamic_rejects_oversized_input`: Beweist dass pre_validate() in compile_dynamic() verdrahtet ist (>5MB abgelehnt) — ✅
- `compile_dynamic_boundary_at_limit`: Off-by-One Guard — Input knapp unter 5MB darf nicht wegen Groesse abgelehnt werden — ✅
- `compile_from_values_rejects_oversized_string`: Beweist dass pre_validate_value() in compile_dynamic_from_values() verdrahtet ist (String >1MB) — ✅
- `compile_from_values_rejects_oversized_array`: Array >10.000 Elemente wird abgelehnt — ✅
- `cli_validate_exit_1_on_invalid_grm`: Exit 1 bei korrupter .grm — ✅
- `cli_validate_exit_0_on_valid_grm`: Exit 0 bei gueltiger .grm (compile + validate Roundtrip) — ✅
- `cli_inspect_exit_1_on_invalid_grm`: Exit 1 bei korrupter .grm — ✅
- `cli_compile_rejects_oversized_input`: CLI compile lehnt >5MB ab mit Exit 1 — ✅
- `header_to_bytes_returns_result`: Compile-time Guard — bricht wenn to_bytes() nicht Result zurueckgibt — ✅

Ergebnis:
- `cargo test --workspace`: 122 tests, 0 failures (85 unit + 9 security integration + 28 other integration)
- `cargo test --workspace --features mcp`: 130 tests, 0 failures
- `cargo clippy --workspace --all-targets -- -D warnings`: clean
- `cargo clippy --workspace --all-targets --features mcp -- -D warnings`: clean
- `cargo fmt --all -- --check`: clean

Abweichungen vom AP:
- **Boundary-Test (1b)**: Option A gewaehlt — viele kleine Felder (je 500 Bytes, unter MAX_STRING_LENGTH) statt einem grossen String. Zusaetzlich Sanity-Assert dass die Testdaten tatsaechlich nahe am Limit sind (> MAX_INPUT_SIZE - 1000). Robuster als der im AP vorgeschlagene Single-String-Ansatz.
- **Keine Abweichung bei Teststruktur**: Alle 4 Gruppen wie im AP spezifiziert implementiert.

## Publish Dry-Run:

- germanic-macros: OK (v0.1.1, no changes)
- germanic: OK (v0.2.1)
